getpid()-Процесс может узнать свой идентификатор (PID),
Вызов fork() создаёт новый процесс посредством копирования вызывающего процесса. 
Описание функции: system () вызовет fork () для создания дочернего процесса. 
Дочерний процесс вызовет строку / bin / sh-c для выполнения команды, 
представленной строкой параметров. 
sh вызывает программу shкак интерпретатор, 
а -cфлаг означает выполнение следующей команды, интерпретируемой этой программой.

В Ubuntu shобычно имеет символическую ссылку на /bin/dash, 
что означает, что если вы выполняете команду с sh -cпомощью dash, 
оболочка будет использоваться для выполнения команды вместо bash. 
Оболочка, вызываемая с shпомощью, зависит от символической ссылки 
- вы можете узнать с readlink -e $(which sh)помощью . 
Вы должны использоватьsh -c, когда хотите выполнить команду конкретно 
с этой оболочкой вместо bash.

После выполнения этой команды он вернется к исходному процессу. 

создает дочерний процесс в родительской оболочке и он заменяет вызванную программу. 
Int execv (const char *filename, char *const argv) (функция). 
Execv функция выполняет файл, именованный filename как новый образ процесса. 
Аргумент argv - массив строк с нулевым символом в конце, который используется, 
чтобы обеспечить значение для аргумента argv функции main программы, 
которая будет выполнена.
Execv функция выполняет файл, именованный filename как новый образ процесса.

Описание функции: execve () используется для выполнения пути к файлу, 
представленного параметром filename. 
Второй параметр передается в исполняемый файл с помощью указателя на массив,
а последний параметр - это новый массив переменных среды, переданный в исполняемый файл. 
Возвращаемое значение: если выполнение выполнено успешно, функция не вернется. 
Если выполнение не удастся, она вернет напрямую -1. Причина сбоя сохраняется в errno.

system() вызывает sh для обработки вашей командной строки,
 чтобы вы могли получить расширение подстановочных знаков и т. Д.
 exec() а его друзья заменяют текущее изображение процесса 
новым изображением процесса.

При system()этом ваша программа продолжает работать, 
и вы получаете некоторый статус о вызванной вами внешней команде.
 При exec()этом ваш процесс уничтожается.

В общем, я думаю, вы могли бы подумать об system()
интерфейсе более высокого уровня. 
Вы могли бы дублировать его функциональность самостоятельно, 
используя некоторую комбинацию fork(), exec(), и wait().

Чтобы ответить на ваш последний вопрос, 
system()вызывает создание дочернего процесса, 
а exec()семейство - нет. Для этого вам нужно будет использоватьfork().
